package com.github.caiiiycuk.pg2sqlite

import java.io.File

case class Config(pgdump: File = new File("dump"), sqlite: File = new File("db"),
                  force: Boolean = false, dateClass: String = Connection.DEFAULT_DATE_CLASS)

object Config extends Log {
  private val parser = new scopt.OptionParser[Config]("postgresql-to-sqlite") {
    head("postgresql-to-sqlite")

    opt[File]('d', "dump") required() valueName ("<dump file>") action { (v, c) =>
      c.copy(pgdump = v)
    } text ("postgresql dump generated by pg_dump")

    opt[File]('o', "out") required() valueName ("<sqlite3 database>") action { (v, c) =>
      c.copy(sqlite = v)
    } text ("sqlite3 database to create")

    opt[Boolean]('f', "force") optional() valueName ("<true|false>") action { (v, c) =>
      c.copy(force = v)
    } text ("recreate database if exists")

    opt[String]('t', "timestamps") optional() valueName ("<integer|text|real>") action { (v, c) =>
      val dc = v.toUpperCase()
      if (dc.equals(Connection.TEXT_DATE_CLASS) || dc.equals(Connection.REAL_DATE_CLASS)) {
        c.copy(dateClass = dc)
      } else {
        c
      }
    } text ("Change sqlite3 date class (default: INTEGER)")

    checkConfig { c =>
      import c._

      if (!pgdump.exists()) {
        failure(s"Dump '${pgdump}' does not exists")
      } else if (sqlite.exists()) {
        if (force) {
          sqlite.delete()
          success
        } else {
          failure(s"Database '${sqlite}' already exists")
        }
      } else {
        success
      }
    }
  }

  def parse(args: Array[String]) = {
    parser.parse(args, Config()) match {
      case Some(config) =>
        Option(System.getenv("SQLITE_TMPDIR")) match {
          case None =>
            log.warn("You should set SQLITE_TMPDIR environment variable to control where sqlite stores temp files")
          case _ =>
        }

        config
      case _ =>
        System.exit(1)
        ???
    }
  }

}
